#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
filter_assemblies.py

Created on Sun Mar 9 18:44:50 2025

This script filters genome assemblies based on BUSCO completeness scores, selecting
the best assembly per species and removing outliers using interquartile range (IQR)
analysis. It outputs filtered assembly and table file lists for downstream use in
the Entheome Genome Extraction Pipeline (EGEP).

@author: ian.bollinger@entheome.org / ian.michael.bollinger@gmail.com
"""
import os
import re
import sys
import pandas as pd


def parse_summary(summary_file):
    """Parse a BUSCO summary file to extract single and duplicated BUSCO counts.

    Reads a `summary.txt` file generated by BUSCO or Compleasm and extracts the counts
    of single-copy (S) and duplicated (D) BUSCOs. Example lines:
        S:98.58%, 1739
        D:0.74%, 13

    Args:
        summary_file (str): Path to the BUSCO summary file.

    Returns:
        tuple: A pair of integers (s_count, d_count) representing single and duplicated
               BUSCO counts, or (None, None) if parsing fails.

    Raises:
        FileNotFoundError: If the summary file does not exist.
        Exception: For other unexpected parsing errors, with an error message printed.
    """
    s_count = None
    d_count = None
    try:
        with open(summary_file, "r") as f:
            lines = f.readlines()
        for line in lines:
            line = line.strip()
            if line.startswith("S:"):
                match = re.search(r"S:\S+%,\s*(\d+)", line)
                if match:
                    s_count = int(match.group(1))
            elif line.startswith("D:"):
                match = re.search(r"D:\S+%,\s*(\d+)", line)
                if match:
                    d_count = int(match.group(1))
    except FileNotFoundError:
        print(f"Error: Summary file not found: {summary_file}")
    except Exception as e:
        print(f"Error reading {summary_file}: {e}")
    return s_count, d_count


def list_egap_output(base_path, compleasm_db):
    """Filter assemblies based on BUSCO completeness and write results to files.

    Traverses the base directory to find assemblies with Compleasm output, selects the
    best assembly per species based on BUSCO completeness (single + duplicated counts),
    removes outliers using IQR, and writes the filtered assembly and table paths to
    "assemblies.txt" and "tables.txt", respectively.

    Args:
        base_path (str): Base directory containing assembly and Compleasm output files.
        compleasm_db (str): Compleasm database identifier (e.g., "basidiomycota").

    Returns:
        None: Outputs are written to "assemblies.txt" and "tables.txt".

    Raises:
        FileNotFoundError: If the base_path does not exist.
        ValueError: If no valid assemblies are found after filtering.
    """
    if not os.path.exists(base_path):
        print(f"Error: Base path does not exist: {base_path}")
        sys.exit(1)

    assembly_paths = []
    assemblies_to_remove = []
    summary_paths = []
    summaries_to_remove = []
    table_paths = []
    tables_to_remove = []

    # Collect assembly, summary, and table paths
    for root, dirs, _ in os.walk(base_path):
        for directory in dirs:
            if f"{compleasm_db}_odb10_compleasm" in directory:
                compleasm_dir_path = os.path.join(root, directory)
                assembly_path = compleasm_dir_path.replace(
                    f"_{compleasm_db}_odb10_compleasm", ".fasta"
                )
                assembly_paths.append(assembly_path)
                summary_path = os.path.join(compleasm_dir_path, "summary.txt")
                summary_paths.append(summary_path)
                table_path = os.path.join(compleasm_dir_path,
                                          f"{compleasm_db}_odb10",
                                          "full_table_busco_format.tsv")
                table_paths.append(table_path)

    if not assembly_paths:
        print(f"Error: No assemblies found in {base_path} with Compleasm output for {compleasm_db}")
        sys.exit(1)

    # Filter assemblies by species, keeping the best based on completeness
    processed_species = set()
    for assembly_file in assembly_paths:
        base_name = os.path.basename(assembly_file)
        if "_" not in base_name:
            print(f"Warning: Skipping malformed filename: {assembly_file}")
            continue
        species_id = "_".join(base_name.split("_")[:2])
        if species_id in processed_species:
            continue
        processed_species.add(species_id)

        matching_assemblies = []
        matching_summaries = []
        matching_tables = []
        for idx, asm in enumerate(assembly_paths):
            if species_id in os.path.basename(asm):
                matching_assemblies.append(asm)
                matching_summaries.append(summary_paths[idx])
                matching_tables.append(table_paths[idx])

        if len(matching_assemblies) > 1:
            print(f"Assemblies with species id {species_id}: {matching_assemblies}")
            busco_data = []
            for asm, summ in zip(matching_assemblies, matching_summaries):
                s_count, d_count = parse_summary(summ)
                if s_count is None or d_count is None:
                    print(f"Warning: Could not parse BUSCO counts for {summ}")
                    continue
                completeness = s_count + d_count
                busco_data.append({"assembly": asm,
                                   "summary": summ,
                                   "table": matching_tables[matching_assemblies.index(asm)],
                                   "S": s_count,
                                   "D": d_count,
                                   "completeness": completeness})

            if not busco_data:
                continue

            busco_df = pd.DataFrame(busco_data)
            busco_df_sorted = busco_df.sort_values(by="completeness", ascending=False)
            best_assembly = busco_df_sorted.iloc[0]["assembly"]
            best_table = busco_df_sorted.iloc[0]["table"]
            best_summary = busco_df_sorted.iloc[0]["summary"]
            print(
                f"Selected best assembly for {species_id}: {best_assembly} "
                f"(completeness: {busco_df_sorted.iloc[0]['completeness']})"
            )
            for _, row in busco_df_sorted.iterrows():
                if row["assembly"] != best_assembly:
                    assemblies_to_remove.append(row["assembly"])
                    tables_to_remove.append(row["table"])
                    summaries_to_remove.append(row["summary"])

    # Apply initial filtering
    final_assembly_paths = [a for a in assembly_paths if a not in assemblies_to_remove]
    final_table_paths = []
    final_summary_paths = []
    for i, a in enumerate(assembly_paths):
        if a not in assemblies_to_remove:
            final_table_paths.append(table_paths[i])
            final_summary_paths.append(summary_paths[i])

    # Remove outliers based on completeness IQR
    final_busco_data = []
    for asm, summ, tab in zip(final_assembly_paths, final_summary_paths, final_table_paths):
        s_count, d_count = parse_summary(summ)
        if s_count is None or d_count is None:
            continue
        completeness = s_count + d_count
        final_busco_data.append({"assembly": asm,
                                 "summary": summ,
                                 "table": tab,
                                 "completeness": completeness})

    if not final_busco_data:
        print("Error: No valid BUSCO data available after initial filtering")
        sys.exit(1)

    final_busco_df = pd.DataFrame(final_busco_data)
    q1 = final_busco_df["completeness"].quantile(0.25)
    q3 = final_busco_df["completeness"].quantile(0.75)
    iqr = q3 - q1
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    print(f"Completeness IQR bounds: lower = {lower_bound}, upper = {upper_bound}")
    outliers = final_busco_df[
        (final_busco_df["completeness"] < lower_bound) |
        (final_busco_df["completeness"] > upper_bound)
    ]
    if not outliers.empty:
        print("Outlier assemblies based on completeness:")
        print(outliers)
    else:
        print("No outlier assemblies detected based on completeness.")
    final_busco_df_no_outliers = final_busco_df[~final_busco_df["assembly"].isin(outliers["assembly"])]
    final_assembly_paths = final_busco_df_no_outliers["assembly"].tolist()
    final_table_paths = final_busco_df_no_outliers["table"].tolist()

    if not final_assembly_paths:
        print("Error: No assemblies remain after outlier removal")
        sys.exit(1)

    # Write filtered results to files
    with open("assemblies.txt", "w") as f:
        f.write("\n".join(final_assembly_paths))
    with open("tables.txt", "w") as f:
        f.write("\n".join(final_table_paths))
    print("PASS:\tFiltered assemblies and tables written to files.")


if __name__ == "__main__":
    """Command-line entry point for filtering assemblies.

    Expects two arguments: the base path and the Compleasm database identifier.
    """
    if len(sys.argv) != 3:
        print("Usage: python filter_assemblies.py <base_path> <compleasm_db>")
        sys.exit(1)
    base_path = sys.argv[1]
    compleasm_db = sys.argv[2]
    list_egap_output(base_path, compleasm_db)